// affirmation.js
// AI-powered positive affirmation generator using Chrome Built-in AI

(function() {
  "use strict";

  const affirmationText = document.getElementById("affirmationText");
  const generateBtn = document.getElementById("generate");
  const closeBtn = document.getElementById("close");
  const loading = document.getElementById("loading");
  const counter = document.getElementById("counter");
  const aiBadge = document.getElementById("aiBadge");

  let affirmationCount = 1;
  let currentEmotion = "neutral";

  // Fallback affirmations for each emotion
  const fallbackAffirmations = {
    anxiety: [
      "I am calm and in control. I breathe deeply and release all tension.",
      "I trust in my ability to handle whatever comes my way.",
      "Peace flows through me with every breath I take.",
      "I am safe, grounded, and at ease in this moment.",
      "My mind is clear and my heart is open to tranquility."
    ],
    anger: [
      "I choose peace over frustration. I release what I cannot control.",
      "I respond to challenges with patience and understanding.",
      "I am in control of my reactions and choose calmness.",
      "I let go of anger and embrace inner peace.",
      "My strength comes from staying centered and composed."
    ],
    negative: [
      "I am resilient and capable. Better moments are coming.",
      "Every challenge I face helps me grow stronger.",
      "I have overcome difficulties before, and I will again.",
      "I am worthy of happiness and positive experiences.",
      "This too shall pass, and brighter days await me."
    ],
    positive: [
      "I embrace this positive energy and share it with the world.",
      "I am grateful for the joy and abundance in my life.",
      "My positive mindset creates positive outcomes.",
      "I radiate confidence, happiness, and inner peace.",
      "I celebrate my wins and appreciate this beautiful moment."
    ],
    neutral: [
      "I am present and aware. I appreciate this moment.",
      "I honor my journey and trust the process of life.",
      "I am exactly where I need to be right now.",
      "I welcome each moment with openness and curiosity.",
      "I am growing, learning, and becoming my best self."
    ]
  };

  // Get random fallback affirmation
  function getRandomFallback(emotion) {
    const affirmations = fallbackAffirmations[emotion] || fallbackAffirmations.neutral;
    return affirmations[Math.floor(Math.random() * affirmations.length)];
  }

  // Get user's recent emotional state from storage
  async function getRecentEmotion() {
    return new Promise((resolve) => {
      chrome.storage.local.get({ emotionHistory: [] }, (data) => {
        const recent = data.emotionHistory.slice(-5);
        if (recent.length === 0) {
          resolve("neutral");
          return;
        }

        // Find most common emotion
        const counts = {};
        recent.forEach(r => {
          counts[r.emotion] = (counts[r.emotion] || 0) + 1;
        });

        let maxEmotion = "neutral";
        let maxCount = 0;
        for (const [emotion, count] of Object.entries(counts)) {
          if (count > maxCount) {
            maxCount = count;
            maxEmotion = emotion;
          }
        }

        resolve(maxEmotion);
      });
    });
  }

  // Generate affirmation using Chrome AI
  async function generateAffirmation() {
    try {
      loading.classList.add("active");
      generateBtn.disabled = true;

      // Get user's recent emotional state
      currentEmotion = await getRecentEmotion();
      console.log("[Affirmation] Generating for emotion:", currentEmotion);

      // Try to use Chrome AI
      if (window.AIService) {
        const affirmation = await AIService.generateAffirmation(currentEmotion);
        
        if (affirmation && affirmation.length > 10) {
          displayAffirmation(affirmation, true);
          return;
        }
      }

      // Fallback to curated affirmations
      const fallback = getRandomFallback(currentEmotion);
      displayAffirmation(fallback, false);

    } catch (error) {
      console.error("[Affirmation] Generation error:", error);
      const fallback = getRandomFallback(currentEmotion);
      displayAffirmation(fallback, false);
    } finally {
      loading.classList.remove("active");
      generateBtn.disabled = false;
    }
  }

  // Display affirmation with animation
  function displayAffirmation(text, isAI) {
    // Fade out
    affirmationText.style.opacity = "0";
    affirmationText.style.transform = "scale(0.95)";

    setTimeout(() => {
      affirmationText.textContent = text;
      affirmationCount++;
      counter.textContent = `Affirmation ${affirmationCount}`;

      // Show AI badge if generated by AI
      if (isAI) {
        aiBadge.style.display = "inline-block";
      } else {
        aiBadge.style.display = "none";
      }

      // Fade in
      affirmationText.style.transition = "all 0.5s ease";
      affirmationText.style.opacity = "1";
      affirmationText.style.transform = "scale(1)";
    }, 300);
  }

  // Track exercise activity
  function trackExercise(completed) {
    chrome.runtime.sendMessage({
      type: "TRACK_EXERCISE",
      exercise: "affirmation",
      completed: completed,
      duration: null
    });
  }

  // Event listeners
  generateBtn.addEventListener("click", generateAffirmation);

  closeBtn.addEventListener("click", () => {
    trackExercise(affirmationCount > 2); // Consider completed if viewed 3+ affirmations
    window.close();
  });

  // Keyboard shortcuts
  document.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      if (!generateBtn.disabled) {
        generateAffirmation();
      }
    } else if (e.key === "Escape") {
      closeBtn.click();
    }
  });

  // Initialize
  (async function init() {
    console.log("[Affirmation] Exercise initialized");
    
    // Load user's emotion and show appropriate first affirmation
    currentEmotion = await getRecentEmotion();
    const firstAffirmation = getRandomFallback(currentEmotion);
    affirmationText.textContent = firstAffirmation;

    // Track that exercise was started
    trackExercise(false);
  })();

})();

